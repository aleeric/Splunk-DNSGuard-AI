############################
#       General Macro      #
############################

[dns_data]
definition = datamodel Network_Resolution search | `drop_dm_object_name(DNS)`
iseval = 0

[extract_sub_parent_domain]
definition = rex field=query "^(?<subdomain>.*?)\.(?<parent_domain>[^.]+\.[^.]+)$"
iseval = 0

[update_anomalous_dns]
definition = outputlookup append=true anomalous_dns_lookup
iseval = 0

[update_anomalous_src]
definition = outputlookup append=true anomalous_src_lookup
iseval = 0

#######################################
#   Volume and Frequency Anomalies    #
#######################################

[dns_volume_frequency_detection]
definition = `dns_data` | bin _time span=1h | stats count by _time, src
iseval = 0

[ml_dns_volume_frequency_detection]
definition = `dns_volume_frequency_detection` | fit DensityFunction count by "src" dist=auto threshold=0.01 into dns_volume_by_src_model
iseval = 0

[dns_volume_frequency_detection]
definition = `dns_data` | bin _time span=1h | stats count by _time, src | fit DensityFunction count by "_time, src" dist=auto threshold=0.01 into dns_volume_by_src_model | rename IsOutlier(count) as isOutlier | where isOutlier=1 | dedup src | eval _key = src, last_update = now(), volume_and_frequency = 1 | table _key, last_update, src, volume_and_frequency | `update_anomalous_src`
iseval = 0


############################
#   Beaconing Detection    #
############################

[dns_beaconing_detection(1)]
args = std
definition = `dns_data` | `extract_sub_parent_domain` | streamstats current=f last(_time) as last_time by src, parent_domain | eval gap = last_time - _time | fit DensityFunction gap by "src,parent_domain" dist=norm threshold=0.01 into dns_beacon_gap_model | search src = "dummy" | append \
    [| summary dns_beacon_gap_model | search std < $std$ NOT std=1e-06]\
     | eval _key = src, last_update = now(), anomalous_type = "Beaconing"\
     | rename parent_domain as dns | table _key, last_update, src, dns, anomalous_type | `update_anomalous_dns`
     | eval beaconing = 1 | table _key, last_update, src, beaconing | `update_anomalous_src`
iseval = 0

############################
#      Burst Activity      #
############################

[dns_burst_activity_detection(1)]
args = thsld #0.000001
definition = `dns_data` | bin _time span=1h | stats count as total_queries by _time, src \
| fit DensityFunction total_queries by "src" dist=expon threshold=$thsld$ into dns_burst_by_src_model \
| rename IsOutlier(total_queries) as isOutlier | where isOutlier=1 | eval _key = src, last_update = now(), burst_activity = 1 | table _key, last_update, src, burst_activity | `update_anomalous_src`
iseval = 0

################################
# DNS Burst Activity Detection #
################################

[dns_burst_activity_detection]
definition = `dns_data` | fields src | streamstats time_window=1m count as count_in_last_minute by src | bucket _time span=1m | stats max(count_in_last_minute) as max_burst_count_per_min by _time src | fit DensityFunction max_burst_count_per_min by "_time,src" dist=auto threshold=0.01 into dns_burst_by_src_model | where isOutlier=1
iseval = 0

############################
#   TXT Record Anomalies   #
############################

[dns_txt_record_detection(1)]
args = thsld #0.0001
definition = `dns_data` | bin _time span=1h | stats count(eval(record_type="TXT")) as txt_queries by _time, src \
| fit DensityFunction txt_queries by "src" dist=auto threshold=$thsld$ into dns_txt_volume_by_src_model \
| rename IsOutlier(txt_queries) as isOutlier | where isOutlier=1 | dedup src | eval _key = src, last_update = now(), txt_record_type = 1 | table _key, last_update, src, txt_record_type | `update_anomalous_src`
iseval = 0

############################
#   ANY Record Anomalies   #
############################

[dns_any_record_detection(1)]
args = thsld #0.0001
definition = `dns_data` | bin _time span=1h | stats count(eval(record_type="ANY")) as any_queries by _time, src \
| fit DensityFunction any_queries by "src" dist=auto threshold=$thsld$ into dns_any_volume_by_src_model \
| rename IsOutlier(any_queries) as isOutlier | where isOutlier=1 | dedup src | eval _key = src, last_update = now(), any_record_type = 1 | table _key, last_update, src, any_record_type | `update_anomalous_src`
iseval = 0

############################
#  HINFO Record Anomalies  #
############################

[dns_hinfo_record_detection(1)]
args = thsld #0.0001
definition = `dns_data` | bin _time span=1h | stats count(eval(record_type="HINFO")) as hinfo_queries by _time, src \
| fit DensityFunction hinfo_queries by "src" dist=auto threshold=$thsld$ into dns_hinfo_volume_by_src_model \
| rename IsOutlier(hinfo_queries) as isOutlier | where isOutlier=1 | dedup src | eval _key = src, last_update = now(), hinfo_record_type = 1 | table _key, last_update, src, hinfo_record_type | `update_anomalous_src`
iseval = 0

############################
#   AXFR Record Anomalies  #
############################

[dns_axfr_record_detection(1)]
args = thsld #0.0001
definition = `dns_data` | bin _time span=1h | stats count(eval(record_type="AXFR")) as axfr_queries by _time, src \
| fit DensityFunction axfr_queries by "src" dist=auto threshold=$thsld$ into dns_axfr_volume_by_src_model \
| rename IsOutlier(axfr_queries) as isOutlier | where isOutlier=1 | dedup src | eval _key = src, last_update = now(), axfr_record_type = 1 | table _key, last_update, src, axfr_record_type | `update_anomalous_src`
iseval = 0

############################
#   Query Length Anomalies  #
############################

[dns_query_length_detection(1)]
args = thsld #0.0001
definition = `dns_data` | eval query_length = len(query) | where isnotnull(query_length) AND query_length > 0 \
| fit DensityFunction query_length by "src" dist=auto threshold=$thsld$ into dns_query_length_by_src_model \
| rename IsOutlier(query_length) as isOutlier  | where isOutlier=1 | dedup src | eval _key = src, last_update = now(), query_length = 1 | table _key, last_update, src, query_length | `update_anomalous_src`
iseval = 0



| fit DensityFunction query_length by "src" dist=auto threshold=0.0001 into 
| rename IsOutlier(query_length) as isOutlier 
| where isOutlier=1
| dedup src
| eval _key = src, last_update = now(), query_length = 1 | table _key, last_update, src, query_length


################################
#    Behavioral Clustering     #
################################

[dns_behavioral_clustering_detection]
definition = | `dns_data` | eval query_length = len(query) \
| rex field=query "^(?<subdomain>.*?)\.(?<parent_domain>[^.]+\.[^.]+)$" | streamstats current=f last(_time) as last_time by src, parent_domain | eval gap = last_time - _time | eventstats stdev(gap) as stdev_gap by src, parent_domain \
| eventstats dc(subdomain) as distinct_subdomains count(eval(record_type="TXT")) as txt_queries count(eval(reply_code="NXDOMAIN")) as nx_queries avg(query_length) as avg_query_len, stdev(query_length) as stdev_query_len max(query_length) as max_query_len by src \
| bin _time span=1h \
| eventstats count as hourly_query_count by _time, src \
| stats avg(hourly_query_count) as avg_query_freq_hourly, \
        avg(distinct_subdomains) as avg_distinct_subdomains, \
        latest(avg_query_len) as avg_len,  \
        latest(stdev_query_len) as stdev_len,  \
        latest(max_query_len) as max_len, \
        sum(hourly_query_count) as total_q, \
        latest(txt_queries) as txt_q,  \
        latest(nx_queries) as nx_q,  \
        min(stdev_gap) as beacon_stdev \
        by src  \
| eval txt_ratio = round(coalesce(txt_q,0) / total_q, 4), nx_ratio = round(coalesce(nx_q,0) / total_q, 4) \
| fillnull value=0 query_freq_hourly, avg_len, stdev_len, max_len, txt_ratio, nx_ratio, beacon_stdev \
| fields src, avg_query_freq_hourly, avg_distinct_subdomains, avg_len, stdev_len, max_len, txt_ratio, nx_ratio, beacon_stdev \
| fit KMeans "avg_distinct_subdomains" "avg_query_freq_hourly" "beacon_stdev" "max_len" "nx_ratio" "txt_ratio" k=5 into dns_behavior_clusters \
| where cluster <= 0 \
| eval _key = src, last_update = now(), behavioral_clustering = 1 | table _key, last_update, src, beaconing | `update_anomalous_src`

iseval = 0




#####

[extract_txt_content]
definition = rex field=answer "\"(?<txt_content>.+)\"" | fillnull txt_content value="" | fields _time, src, dest, txt_content
iseval = 0 